import weakref
import inspect
import numpy as np
import ctypes

import glfw.GLFW as glfw
import OpenGL.GL as gl
from windowing.frame_buffer_like.frame_buffer_like_bp import FBL

class GLFW_GL_tracker:
    """
    Stores opengl binding state.

    Please store the object withint glfw.contex wrapping class object
    as a representation of unique glfw.context.

    There are two main purpose of the class.
    1. To store gl info such as generated buffers and currently bound
    buffers and other info good to be logged.

    2. This object represents a unique glfw context, meaning shared
    glfw contexts will contain one GL_tracker object. The characteristics
    of uniqueness is built for the reasons:
        1) Couldn't find a way to extract unique glfw object(with unique id,
           ex) glfw.get_current_context() doesn't return glfw context object
           generated by glfw.create_window()).
        2) Think glfw.context doesn't store its other shared contexts.

    """
    # instance dict of the trackers bound with FBL(Window) object
    _FBLs = weakref.WeakKeyDictionary()

    def __init__(self, bound_object):
        # store instance
        self.__class__._FBLs[bound_object] = self
        self._bound_object = bound_object

        # use dict to store generated's additional state information
        self._programs = {}
        self._buffers = {}
        self._vertex_arrays = {}
        self._shaders = {}
        self._textures = {}

        # stores current binding
        self._bound_program = int
        self._bound_vertex_array = int
        self._bound_buffer = {
            'GL_ARRAY_BUFFER': None,
            'GL_ELEMENT_ARRAY_BUFFER': None
        }
        # texture
        self._bound_texture = {
            'GL_TEXTURE_2D' : None
        }
        self._active_texture = str
        self._param_texture = {
            'GL_TEXTURE_2D' : {}
        }

    def give_tracker_to(self, window):
        """
        Stores new Window object and returns self.
        Different windows sharing one tracker means
        their glfw.context is shared.

        :param window: fbl.window object to give to
        :return: object of tracker
        """
        self._FBLs[window] = self
        return self

class context_check:
    """
    Decorator for all openGL functions.

    Wanted to hijack everty classmethod calls through magic method
    \but couldn't find one.

    The class does one thing : check if openGL function are called while current
    bound 'glfw.context wrapping object'(ex)Window) has a tracker to log to.
    """

    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        # checks whether current fbl has tracker within it
        if FBL.get_current() not in GLFW_GL_tracker._FBLs:
            raise Exception('Frame_buffer_like object not bound with trackable_GL')
        # modified to insert Trackable_openGL type as cls
        return lambda *args,**kwargs: self.func(Trackable_openGL, *args, **kwargs)

class vao_related:
    """
    Decorator for vao_related functions.
    If glfw context doesn't support vertex array sharing this function will trigger
    to make all shared windows have same vertex array shape, operations by
    calling shared windows through assigned 'shared_windows' argument.

    Built as a type to postpone calling? - if not problem with
    feeding type(Trackabl_openGL) as an argument.
    """
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        if not Trackable_openGL._spec_vertex_array_shared:

            def func(*args, **kwargs):
                fbl = FBL.get_current()
                windows = fbl.shared_windows + [fbl, ]
                for win in windows:
                    win.make_window_current()
                    return_v = self.func(*args, **kwargs)
                return return_v

            return func(*args, **kwargs)

        else:
            return self.func(*args, **kwargs)


class Trackable_openGL:
    """
    Collection of openGL functions and constants.
    Will be appended as other functions gets needed.

    *WARNING
    Be conservative modifying openGL functions in any ways.
    This binder class is built primarily to hijack openGL function call and
    log info with glfw context. Some automation can be made but modifying
    name of function, name of parameter, number of parameters is not recommended.
    Can cause confusion to general users referencing issued openGL specification.
    """

    # clear
    GL_COLOR_BUFFER_BIT = gl.GL_COLOR_BUFFER_BIT
    GL_DEPTH_BUFFER_BIT = gl.GL_DEPTH_BUFFER_BIT
    # test
    GL_SCISSOR_TEST = gl.GL_SCISSOR_TEST
    GL_DEPTH_TEST = gl.GL_DEPTH_TEST
    # color blending
    GL_BLEND = gl.GL_BLEND
    GL_SRC_ALPHA = gl.GL_SRC_ALPHA
    GL_ONE_MINUS_SRC_ALPHA = gl.GL_ONE_MINUS_SRC_ALPHA

    # draw setting
    GL_DYNAMIC_DRAW = gl.GL_DYNAMIC_DRAW
    GL_STATIC_DRAW = gl.GL_STATIC_DRAW

    # element_draw modes
    GL_TRIANGLE_STRIP = gl.GL_TRIANGLE_STRIP

    # value types
    GL_TRUE = gl.GL_TRUE
    GL_FALSE = gl.GL_FALSE

    GL_UNSIGNED_BYTE = gl.GL_UNSIGNED_BYTE
    GL_UNSIGNED_SHORT = gl.GL_UNSIGNED_SHORT
    GL_UNSIGNED_INT = gl.GL_UNSIGNED_INT

    GL_INT = gl.GL_INT
    GL_FLOAT = gl.GL_FLOAT

    # shader
    GL_VERTEX_SHADER = gl.GL_VERTEX_SHADER
    GL_FRAGMENT_SHADER = gl.GL_FRAGMENT_SHADER
    GL_COMPILE_STATUS = gl.GL_COMPILE_STATUS

    # array buffer
    GL_ARRAY_BUFFER = gl.GL_ARRAY_BUFFER
    GL_ARRAY_BUFFER_BINDING = gl.GL_ARRAY_BUFFER_BINDING
    GL_ELEMENT_ARRAY_BUFFER = gl.GL_ELEMENT_ARRAY_BUFFER
    GL_ELEMENT_ARRAY_BUFFER_BINDING = gl.GL_ELEMENT_ARRAY_BUFFER_BINDING

    # get_string
    GL_VERSION = gl.GL_VERSION
    GL_VENDOR = gl.GL_VENDOR
    GL_RENDERER = gl.GL_RENDERER

    # texture format
    GL_RGBA = gl.GL_RGBA
    GL_RGB = gl.GL_RGB
    GL_R = gl.GL_R

    # texture setting
    GL_TEXTURE_2D = gl.GL_TEXTURE_2D
    GL_TEXTURE_MIN_FILTER = gl.GL_TEXTURE_MIN_FILTER
    GL_TEXTURE_MAG_FILTER = gl.GL_TEXTURE_MAG_FILTER
    GL_TEXTURE_WRAP_S = gl.GL_TEXTURE_WRAP_S
    GL_TEXTURE_WRAP_T = gl.GL_TEXTURE_WRAP_T
    GL_TEXTURE_WRAP_R = gl.GL_TEXTURE_WRAP_R
    GL_LINEAR = gl.GL_LINEAR
    GL_REPEAT = gl.GL_REPEAT

    # texture slot
    GL_TEXTURE0 = gl.GL_TEXTURE0
    for i in range(1,31):
        exec(f'GL_TEXTURE{i} = gl.GL_TEXTURE{i}')

    @classmethod
    def context_specification_check(cls):
        """
        Checks glfw, openGL operation and stores some info as class argument.

        *Run once before creating any other glfw contexts.

        :return: None
        """

        # checking shared openGL components under shared glfw contexts
        glfw.glfwWindowHint(glfw.GLFW_VISIBLE, glfw.GLFW_FALSE) # don't show
        a = glfw.glfwCreateWindow(10, 10, 'first', None, None) # two test windows
        b = glfw.glfwCreateWindow(10, 10, 'second', None, a)
        glfw.glfwWindowHint(glfw.GLFW_VISIBLE, glfw.GLFW_TRUE) # invalidate for real operation

        glfw.glfwMakeContextCurrent(a)

        a_bo = gl.glGenBuffers(1)
        a_vao = gl.glGenVertexArrays(1)
        a_program = gl.glCreateProgram()
        a_shader = gl.glCreateShader(gl.GL_VERTEX_SHADER)
        a_texture = gl.glGenTextures(1)

        glfw.glfwMakeContextCurrent(b)

        b_bo = gl.glGenBuffers(1)
        b_vao = gl.glGenVertexArrays(1)
        b_shader = gl.glCreateShader(gl.GL_VERTEX_SHADER)
        b_program = gl.glCreateProgram()
        b_texture = gl.glGenTextures(1)

        # comparison: same value means component not shared between shared context
        cls._spec_buffer_shared = True if a_bo != b_bo else False
        cls._spec_vertex_array_shared = True if a_vao != b_vao else False
        cls._spec_shader_shared = True if a_shader != b_shader else False
        cls._spec_program_shared = True if a_program != b_program else False
        cls._spec_texture_shared = True if a_texture != b_texture else False


        # generate version, renderer info
        cls._spec_version = gl.glGetString(gl.GL_VERSION)
        cls._spec_renderer = gl.glGetString(gl.GL_RENDERER)
        cls._spec_vendor = gl.glGetString(gl.GL_VENDOR)

        # from the bug of intel graphics, need this mark to trigger extra ibo binding
        cls.vao_stores_ibo = False
        # TODO write down test to verify whether GL_ELEMENT_ARRAY_BUFFER can be
        #   bound with VAO. Don't know how yet.

        # remove tester contexts
        glfw.glfwDestroyWindow(a)
        glfw.glfwDestroyWindow(b)

    @context_check
    def glGenBuffers(cls,n,buffers=None):
        index = gl.glGenBuffers(n, buffers)
        cls.ins()._buffers[index] = {}
        return index

    @context_check
    @vao_related
    def glGenVertexArrays(cls, n, arrays=None):
        index = gl.glGenVertexArrays(n, arrays)
        cls.ins()._vertex_arrays[index] = {}

        return index

    @context_check
    @vao_related
    def glBindVertexArray(cls, array):
        gl.glBindVertexArray(array)

    @context_check
    @vao_related
    def glEnableVertexAttribArray(cls, index):
        gl.glEnableVertexAttribArray(index)

    @context_check
    @vao_related
    def glVertexAttribPointer(cls, index, type, size, normalized, stride, pointer):
        gl.glVertexAttribPointer(index, type, size, normalized, stride, pointer)

    @context_check
    @vao_related
    def glBindBuffer(cls, target, buffer):
        buffer_d = cls.ins()._bound_buffer
        if target == cls.GL_ARRAY_BUFFER:
            buffer_d['GL_ARRAY_BUFFER'] = buffer
        elif target == cls.GL_ELEMENT_ARRAY_BUFFER:
            buffer_d['GL_ELEMENT_ARRAY_BUFFER'] = buffer
        else:
            raise
        gl.glBindBuffer(target, buffer)

    @context_check
    def glBufferData(cls, target, size, data, usage):
        # TODO is automated size calculation good?
        gl.glBufferData(target, size, data, usage)

    @context_check
    def glCreateProgram(cls):
        index = gl.glCreateProgram()
        cls.ins()._programs[index] = {'linked': False}
        return index

    @context_check
    def glUseProgram(cls, program):
        cls.ins()._bound_program = program
        gl.glUseProgram(program)

    @context_check
    def glCreateShader(cls, type):
        index = gl.glCreateShader(type)
        cls.ins()._shaders[index] = {}

        return index

    @context_check
    def glClearColor(cls,r,g,b,a):
        gl.glClearColor(r,g,b,a)

    @context_check
    def glClear(cls, mask):
        gl.glClear(mask)

    @context_check
    def glEnable(cls, cap):
        gl.glEnable(cap)

    @context_check
    def glBlendFunc(cls, sfactor,dfactor):
        gl.glBlendFunc(sfactor,dfactor)

    @context_check
    def glViewport(cls,x,y,width,height):
        gl.glViewport(x,y,width,height)

    @context_check
    def glScissor(cls,x,y,width,height):
        gl.glScissor(x,y,width,height)

    @context_check
    def glShaderSource(cls, shader, count, string=None, length=None):
        gl.glShaderSource(shader, count, string, length)

    @context_check
    def glCompileShader(cls, shader):
        gl.glCompileShader(shader)

    @context_check
    def glGetShaderiv(cls, shader, pname, param=None):
        return gl.glGetShaderiv(shader,pname)

    @context_check
    def glAttachShader(cls, program, shader):
        gl.glAttachShader(program, shader)

    @context_check
    def glLinkProgram(cls, program):
        cls.ins()._programs[program]['linked'] = True
        gl.glLinkProgram(program)

    @context_check
    def glValidateProgram(cls, program):
        gl.glValidateProgram(program)

    @context_check
    def glDeleteShader(cls, shader):
        gl.glDeleteShader(shader)
        del cls.ins()._shaders[shader]

    @context_check
    def glBindAttribLocation(cls, program, index, name):
        gl.glBindAttribLocation(program, index, name)

    @context_check
    def glGetUniformLocation(cls, program, name):
        index = gl.glGetUniformLocation(program, name)
        return index




    @context_check
    def glGenTextures(cls, n, textures=None):
        index = gl.glGenTextures(n, textures)
        cls.ins()._textures[index] = {}
        return index

    @context_check
    def glTexParameter(cls, target, pname, parameter):
        gl.glTexParameter(target, pname, parameter)
        if target == gl.GL_TEXTURE_2D:
            tname = 'GL_TEXTURE_2D'

        if pname == gl.GL_TEXTURE_MIN_FILTER:
            name = 'GL_TEXTURE_MIN_FILTER'
        elif pname == gl.GL_TEXTURE_MAG_FILTER:
            name = 'GL_TEXTURE_MAG_FILTER'
        elif pname == gl.GL_TEXTURE_WRAP_S:
            name = 'GL_TEXTURE_WRAP_S'
        elif pname == gl.GL_TEXTURE_WRAP_R:
            name = 'GL_TEXTURE_WRAP_R'
        elif pname == gl.GL_TEXTURE_WRAP_T:
            name = 'GL_TEXTURE_WRAP_T'

        if parameter == gl.GL_LINEAR:
            value = 'GL_LINEAR'
        elif parameter == gl.GL_REPEAT:
            value = 'GL_VALUE'


        cls.ins()._param_texture[tname][name] = value

    @context_check
    def glActiveTexture(cls, texture):
        gl.glActiveTexture(texture)
        base = gl.GL_TEXTURE0
        n = texture - base
        cls.ins()._active_texture = f'GL_TEXTURE{n}'

    @context_check
    def glBindTexture(cls, target, texture):
        gl.glBindTexture(target, texture)

        if target == gl.GL_TEXTURE_2D:
            name = 'GL_TEXTURE_2D'

        cls.ins()._bound_texture[name] = texture

    @context_check
    def glBufferSubData(cls,target,offset,size,data):
        gl.glBufferSubData(target,offset,size,data)

    @context_check
    def glUniformMatrix4fv(cls, location, count, transpose, value):
        gl.glUniformMatrix4fv(location, count, transpose, value)
    @context_check

    def glUniform4fv(cls, location, count, value):
        gl.glUniform4fv(location, count, value)

    @context_check
    def glUniform1i(cls, location, v0):
        gl.glUniform1i(location, v0)

    @context_check
    def glDrawElements(cls,mode,count,type,indices):
        gl.glDrawElements(mode,count,type,indices)

    @context_check
    def glReadPixels(cls,x,y,width,height,format,type,pixels=None):
        return gl.glReadPixels(x,y,width,height,format,type,pixels)

    @context_check
    def glGetIntegerv(cls,pname,data):
        return gl.glGetIntegerv(pname,data)

    @context_check
    def glGetString(cls, name):
        return gl.glGetString(name)


    @classmethod
    def fbl(cls):
        return FBL.get_current()

    @classmethod
    def ins(cls):
        return GLFW_GL_tracker._FBLs[FBL.get_current()]

